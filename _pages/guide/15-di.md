## Dependency Injection

This part of matatdor provide a simple C++ dependency injection or service locator mechanism.

The mechanism is as simple as possible. Every service can be injected with the ```inject<T>``` class.
Once the dependencies are set up each dependency can be injected like this:

```cpp
di::inject<igreeter> greeter;
greeter->greet()
```

### Setting up the Dependency Repository

Before injection can take place the dependencies must be configured. This means
a dependency injection module must be filled with all mapped dependencies.

_matador_ comes with a global service repository where the dependencies can be mapped.

```cpp
di::install([](di::module &m) {
  m.bind<igreeter>()->to_singleton<simple_greeter>();
});
```

With this configuration it is possible to inject our greeter everywhere.

To ensure this behaviour a singleton repository providing all installed services
is always accessible. Though the singleton pattern meant to be an _anti-pattern_
I decided to use it here for practical reason.

But it is also possible to create a use such a module on your own. Then you have to pass
it wherever you want to use dependency injection.

```cpp
di::module m;
m.bind<igreeter>()->to_singleton<simple_greeter>();
```

### Named Services

It is also possible to bind services with a name.

```cpp
di::install([](di::module &m) {
  m.bind<igreeter>("students")->to_singleton<students_greeter>();
  m.bind<igreeter>("teachers")->to_singleton<teacher_greeter>();
});
```

### Service Types

A service can be bound by now in four different ways:

- in transient scope (every inject leads to a new instance)
```cpp
// register the transient strategy (always a new instance)
template < class T, typename ...Args >
di::proxy<i>::to(Args &&...args);
```
- in singleton scope (every inject leads to the same instance)
```cpp
// register the singleton strategy (always the same instance) 
template < class T, typename ...Args >
di::proxy<i>::to_singleton(Args &&...args);
```
- as a given instance (every inject leads to the provided instance)
```cpp
// register the given instance
template < class T >
di::proxy<i>::to_instance(T &&obj);
```
- in singleton per thread scope (every inject leads to the same instance with current thread)
```cpp
// register the singleton per thread strategy (always the same instance) 
template < class T, typename ...Args >
di::proxy<i>::to_singleton_per_thread(Args &&...args);
```

Except for ```to_instance()``` every type is able to take
parameters to create the service.

```cpp
di::install([](di::module &m) {
  m.bind<igreeter>().to_singleton<custom_greeter>("hello everybody");
});
```

### Injecting

```cpp
// injection from global repository
inject<igreeter> i;

// named injection from global repository
inject<igreeter> i("students");

// named injection from local repository
di::module m;
// setup ...
inject<igreeter> i(m, "students");
```