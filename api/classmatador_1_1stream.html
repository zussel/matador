---
layout: reference
title: matador::stream&lt; T &gt; Class Template Reference
---
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematador.html">matador</a></li><li class="navelem"><a class="el" href="classmatador_1_1stream.html">stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classmatador_1_1stream-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">matador::stream&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;stream.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a638b752bc6d35c488a72f5cc8f44c062" id="r_a638b752bc6d35c488a72f5cc8f44c062"><td class="memItemLeft" align="right" valign="top">typedef detail::stream_element_processor_iterator&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a638b752bc6d35c488a72f5cc8f44c062">iterator</a></td></tr>
<tr class="separator:a638b752bc6d35c488a72f5cc8f44c062"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7055869f2101e41021d568be289f2745" id="r_a7055869f2101e41021d568be289f2745"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a7055869f2101e41021d568be289f2745">stream</a> ()=default</td></tr>
<tr class="separator:a7055869f2101e41021d568be289f2745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d665bc57cb1e34da7229650ec987906" id="r_a3d665bc57cb1e34da7229650ec987906"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a3d665bc57cb1e34da7229650ec987906">stream</a> (const <a class="el" href="classmatador_1_1stream.html">stream</a> &amp;x)=default</td></tr>
<tr class="separator:a3d665bc57cb1e34da7229650ec987906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa76ce203779eb7ccd3fa54de4bb7d10" id="r_afa76ce203779eb7ccd3fa54de4bb7d10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#afa76ce203779eb7ccd3fa54de4bb7d10">stream</a> (<a class="el" href="classmatador_1_1stream.html">stream</a> &amp;&amp;x) noexcept=default</td></tr>
<tr class="separator:afa76ce203779eb7ccd3fa54de4bb7d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76894fbc9183825ecf24a2b4466c27a0" id="r_a76894fbc9183825ecf24a2b4466c27a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a76894fbc9183825ecf24a2b4466c27a0">operator=</a> (const <a class="el" href="classmatador_1_1stream.html">stream</a> &amp;x)=default</td></tr>
<tr class="separator:a76894fbc9183825ecf24a2b4466c27a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64672af4acc2a41277130a48b81a0cd1" id="r_a64672af4acc2a41277130a48b81a0cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a64672af4acc2a41277130a48b81a0cd1">operator=</a> (<a class="el" href="classmatador_1_1stream.html">stream</a> &amp;&amp;x) noexcept=default</td></tr>
<tr class="separator:a64672af4acc2a41277130a48b81a0cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af471b3b9cbe820e50ebbb5a741998ca2" id="r_af471b3b9cbe820e50ebbb5a741998ca2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#af471b3b9cbe820e50ebbb5a741998ca2">stream</a> (std::shared_ptr&lt; detail::stream_element_processor&lt; T &gt; &gt; <a class="el" href="classmatador_1_1stream.html#a44e56fc6aac6c731a09b791b6cd97803">processor</a>)</td></tr>
<tr class="separator:af471b3b9cbe820e50ebbb5a741998ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84907f6a4ee736c427ce0c642991d9ec" id="r_a84907f6a4ee736c427ce0c642991d9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a84907f6a4ee736c427ce0c642991d9ec">operator=</a> (const std::shared_ptr&lt; detail::stream_element_processor&lt; T &gt; &gt; &amp;<a class="el" href="classmatador_1_1stream.html#a44e56fc6aac6c731a09b791b6cd97803">processor</a>)</td></tr>
<tr class="separator:a84907f6a4ee736c427ce0c642991d9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d9ec3cef6dab4d0e7946fc4e06d78f" id="r_ad6d9ec3cef6dab4d0e7946fc4e06d78f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html#a638b752bc6d35c488a72f5cc8f44c062">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#ad6d9ec3cef6dab4d0e7946fc4e06d78f">begin</a> ()</td></tr>
<tr class="separator:ad6d9ec3cef6dab4d0e7946fc4e06d78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcf7abbad0decbec0dbf767cabe35ae" id="r_adfcf7abbad0decbec0dbf767cabe35ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html#a638b752bc6d35c488a72f5cc8f44c062">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#adfcf7abbad0decbec0dbf767cabe35ae">end</a> ()</td></tr>
<tr class="separator:adfcf7abbad0decbec0dbf767cabe35ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29052a25033bdee7d191cf9b705096a6" id="r_a29052a25033bdee7d191cf9b705096a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a29052a25033bdee7d191cf9b705096a6">take</a> (std::size_t <a class="el" href="classmatador_1_1stream.html#afa79755850ea6e1e79168038f4da5d24">count</a>)</td></tr>
<tr class="separator:a29052a25033bdee7d191cf9b705096a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fefc80ac3285932cad80de552f35a81" id="r_a9fefc80ac3285932cad80de552f35a81"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a9fefc80ac3285932cad80de552f35a81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a9fefc80ac3285932cad80de552f35a81">take_while</a> (Predicate pred)</td></tr>
<tr class="separator:a9fefc80ac3285932cad80de552f35a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5164896b4ebe3fd1fe7b601f232dc1c1" id="r_a5164896b4ebe3fd1fe7b601f232dc1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a5164896b4ebe3fd1fe7b601f232dc1c1">skip</a> (std::size_t <a class="el" href="classmatador_1_1stream.html#afa79755850ea6e1e79168038f4da5d24">count</a>)</td></tr>
<tr class="separator:a5164896b4ebe3fd1fe7b601f232dc1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b53414bfe2f25c23ae2dbfc6fb937d" id="r_a57b53414bfe2f25c23ae2dbfc6fb937d"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a57b53414bfe2f25c23ae2dbfc6fb937d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a57b53414bfe2f25c23ae2dbfc6fb937d">skip_while</a> (Predicate pred)</td></tr>
<tr class="separator:a57b53414bfe2f25c23ae2dbfc6fb937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168df705ec02d4bfd18d488de9db66cd" id="r_a168df705ec02d4bfd18d488de9db66cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a168df705ec02d4bfd18d488de9db66cd">every</a> (std::size_t <a class="el" href="classmatador_1_1stream.html#afa79755850ea6e1e79168038f4da5d24">count</a>)</td></tr>
<tr class="separator:a168df705ec02d4bfd18d488de9db66cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf66f571e273e987c5d741c3a1b581c" id="r_afdf66f571e273e987c5d741c3a1b581c"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:afdf66f571e273e987c5d741c3a1b581c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#afdf66f571e273e987c5d741c3a1b581c">filter</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:afdf66f571e273e987c5d741c3a1b581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60e946011fffcf841d778cfea0ea8cf" id="r_af60e946011fffcf841d778cfea0ea8cf"><td class="memTemplParams" colspan="2">template&lt;typename Predicate , typename R  = typename std::result_of&lt;Predicate&amp;(T)&gt;::type&gt; </td></tr>
<tr class="memitem:af60e946011fffcf841d778cfea0ea8cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#af60e946011fffcf841d778cfea0ea8cf">map</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:af60e946011fffcf841d778cfea0ea8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377c841563a76860d4738b73891a9f8" id="r_a8377c841563a76860d4738b73891a9f8"><td class="memTemplParams" colspan="2">template&lt;typename Predicate , typename R  = typename std::result_of&lt;Predicate&amp;(T)&gt;::type::value_type&gt; </td></tr>
<tr class="memitem:a8377c841563a76860d4738b73891a9f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a8377c841563a76860d4738b73891a9f8">flatmap</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:a8377c841563a76860d4738b73891a9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f16bccfeb2c4f75b00e7a37cd0a7d8e" id="r_a4f16bccfeb2c4f75b00e7a37cd0a7d8e"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a4f16bccfeb2c4f75b00e7a37cd0a7d8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a4f16bccfeb2c4f75b00e7a37cd0a7d8e">peek</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:a4f16bccfeb2c4f75b00e7a37cd0a7d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba287ce0b13c7d565a821c7e7a24c6" id="r_a38ba287ce0b13c7d565a821c7e7a24c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a38ba287ce0b13c7d565a821c7e7a24c6">concat</a> (const <a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:a38ba287ce0b13c7d565a821c7e7a24c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0735b5a00a6d78259fe15d7b778575d" id="r_ae0735b5a00a6d78259fe15d7b778575d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#ae0735b5a00a6d78259fe15d7b778575d">pack_every</a> (std::size_t packsize)</td></tr>
<tr class="separator:ae0735b5a00a6d78259fe15d7b778575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34505bd3cfe4f45f0d544c90dc66f1e" id="r_ab34505bd3cfe4f45f0d544c90dc66f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#ab34505bd3cfe4f45f0d544c90dc66f1e">first</a> ()</td></tr>
<tr class="separator:ab34505bd3cfe4f45f0d544c90dc66f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d792b455ffea60ef118bddd137923f9" id="r_a6d792b455ffea60ef118bddd137923f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a6d792b455ffea60ef118bddd137923f9">last</a> ()</td></tr>
<tr class="separator:a6d792b455ffea60ef118bddd137923f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea700c32b4ee12577e27374be474291b" id="r_aea700c32b4ee12577e27374be474291b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#aea700c32b4ee12577e27374be474291b">min</a> ()</td></tr>
<tr class="separator:aea700c32b4ee12577e27374be474291b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada936bc6b5ea90cdf2b30c93d41dc20a" id="r_ada936bc6b5ea90cdf2b30c93d41dc20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#ada936bc6b5ea90cdf2b30c93d41dc20a">max</a> ()</td></tr>
<tr class="separator:ada936bc6b5ea90cdf2b30c93d41dc20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591c3a36bb085dd4252459f7bfd4d68c" id="r_a591c3a36bb085dd4252459f7bfd4d68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a591c3a36bb085dd4252459f7bfd4d68c">at</a> (std::size_t index)</td></tr>
<tr class="separator:a591c3a36bb085dd4252459f7bfd4d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5090ba06d89077916a744d781747824d" id="r_a5090ba06d89077916a744d781747824d"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a5090ba06d89077916a744d781747824d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a5090ba06d89077916a744d781747824d">any</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:a5090ba06d89077916a744d781747824d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1b44b66138d284100d696969b2c321" id="r_a8f1b44b66138d284100d696969b2c321"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a8f1b44b66138d284100d696969b2c321"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a8f1b44b66138d284100d696969b2c321">all</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:a8f1b44b66138d284100d696969b2c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9fad71791eadee9171f1dbca458ae7" id="r_a3f9fad71791eadee9171f1dbca458ae7"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a3f9fad71791eadee9171f1dbca458ae7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a3f9fad71791eadee9171f1dbca458ae7">none</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:a3f9fad71791eadee9171f1dbca458ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa79755850ea6e1e79168038f4da5d24" id="r_afa79755850ea6e1e79168038f4da5d24"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#afa79755850ea6e1e79168038f4da5d24">count</a> ()</td></tr>
<tr class="separator:afa79755850ea6e1e79168038f4da5d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3251274c643e357398783b2099dcbf" id="r_a2a3251274c643e357398783b2099dcbf"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a2a3251274c643e357398783b2099dcbf"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a2a3251274c643e357398783b2099dcbf">count</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:a2a3251274c643e357398783b2099dcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cfcf09a9dc7b003a80c7256c599811" id="r_a00cfcf09a9dc7b003a80c7256c599811"><td class="memTemplParams" colspan="2">template&lt;typename Accumulator &gt; </td></tr>
<tr class="memitem:a00cfcf09a9dc7b003a80c7256c599811"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a00cfcf09a9dc7b003a80c7256c599811">reduce</a> (Accumulator &amp;&amp;accu)</td></tr>
<tr class="separator:a00cfcf09a9dc7b003a80c7256c599811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cbb87cb80a40ce1f317d28c0ed91b2" id="r_a55cbb87cb80a40ce1f317d28c0ed91b2"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Accumulator &gt; </td></tr>
<tr class="memitem:a55cbb87cb80a40ce1f317d28c0ed91b2"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a55cbb87cb80a40ce1f317d28c0ed91b2">reduce</a> (const U &amp;identity, Accumulator &amp;&amp;accu)</td></tr>
<tr class="separator:a55cbb87cb80a40ce1f317d28c0ed91b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f0b951edda866b3c40caa5c0e25d14" id="r_a28f0b951edda866b3c40caa5c0e25d14"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Accumulator , typename R  = typename std::result_of&lt;U&amp;(T)&gt;::type&gt; </td></tr>
<tr class="memitem:a28f0b951edda866b3c40caa5c0e25d14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a28f0b951edda866b3c40caa5c0e25d14">reduce_idfunc</a> (const U &amp;identity_fun, Accumulator &amp;&amp;accu)</td></tr>
<tr class="separator:a28f0b951edda866b3c40caa5c0e25d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13beb5bed8c26a4a5d7ac7493bac148c" id="r_a13beb5bed8c26a4a5d7ac7493bac148c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a13beb5bed8c26a4a5d7ac7493bac148c">print_to</a> (std::ostream &amp;out, const char *delim=&quot; &quot;)</td></tr>
<tr class="separator:a13beb5bed8c26a4a5d7ac7493bac148c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862808f6663bd3d9e75c5c36a256b68e" id="r_a862808f6663bd3d9e75c5c36a256b68e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class ... &gt; class C, class Allocator  = std::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a862808f6663bd3d9e75c5c36a256b68e"><td class="memTemplItemLeft" align="right" valign="top">C&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a862808f6663bd3d9e75c5c36a256b68e">collect</a> ()</td></tr>
<tr class="separator:a862808f6663bd3d9e75c5c36a256b68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935df5c1f1ecf3f5647485d534bb7a5f" id="r_a935df5c1f1ecf3f5647485d534bb7a5f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class ... &gt; class C, class Key , class Value , typename KeyFunc , typename ValueFunc &gt; </td></tr>
<tr class="memitem:a935df5c1f1ecf3f5647485d534bb7a5f"><td class="memTemplItemLeft" align="right" valign="top">C&lt; Key, Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a935df5c1f1ecf3f5647485d534bb7a5f">collect</a> (const KeyFunc &amp;key_func, const ValueFunc &amp;value_func)</td></tr>
<tr class="separator:a935df5c1f1ecf3f5647485d534bb7a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8412764b48de693f575d76926dc9293" id="r_af8412764b48de693f575d76926dc9293"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:af8412764b48de693f575d76926dc9293"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#af8412764b48de693f575d76926dc9293">for_each</a> (Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:af8412764b48de693f575d76926dc9293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e56fc6aac6c731a09b791b6cd97803" id="r_a44e56fc6aac6c731a09b791b6cd97803"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; detail::stream_element_processor&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a44e56fc6aac6c731a09b791b6cd97803">processor</a> ()</td></tr>
<tr class="separator:a44e56fc6aac6c731a09b791b6cd97803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6355983303d93fcbcd9d8353b97877f" id="r_ae6355983303d93fcbcd9d8353b97877f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#ae6355983303d93fcbcd9d8353b97877f">join</a> ()</td></tr>
<tr class="separator:ae6355983303d93fcbcd9d8353b97877f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11840a4307c62b91a3c911d2e5f3ce85" id="r_a11840a4307c62b91a3c911d2e5f3ce85"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#a11840a4307c62b91a3c911d2e5f3ce85">join</a> (const std::string &amp;delimiter)</td></tr>
<tr class="separator:a11840a4307c62b91a3c911d2e5f3ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72db81fa355ad662509ec1b752b4dac" id="r_ac72db81fa355ad662509ec1b752b4dac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1stream.html#ac72db81fa355ad662509ec1b752b4dac">join</a> (const std::string &amp;delimiter, const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="separator:ac72db81fa355ad662509ec1b752b4dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class matador::stream&lt; T &gt;</div><p>The stream class allows stream like data processing with lazy evaluation.</p>
<p>It provides a couple of stream element processors like "filter", "map" or "skip".</p>
<p>There are also some stream terminators allowing to get a single result based on the evaluated stream like "min", "max" or "any".</p>
<p>Once a steam is completely processed it can't be processed again.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the stream elements </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a638b752bc6d35c488a72f5cc8f44c062" name="a638b752bc6d35c488a72f5cc8f44c062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638b752bc6d35c488a72f5cc8f44c062">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef detail::stream_element_processor_iterator&lt;T&gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut to stream iterator type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7055869f2101e41021d568be289f2745" name="a7055869f2101e41021d568be289f2745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7055869f2101e41021d568be289f2745">&#9670;&#160;</a></span>stream() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor </p>

</div>
</div>
<a id="a3d665bc57cb1e34da7229650ec987906" name="a3d665bc57cb1e34da7229650ec987906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d665bc57cb1e34da7229650ec987906">&#9670;&#160;</a></span>stream() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copys the steam from given stream x</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Stream to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa76ce203779eb7ccd3fa54de4bb7d10" name="afa76ce203779eb7ccd3fa54de4bb7d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa76ce203779eb7ccd3fa54de4bb7d10">&#9670;&#160;</a></span>stream() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy move stream from given stream x</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Stream to copy move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af471b3b9cbe820e50ebbb5a741998ca2" name="af471b3b9cbe820e50ebbb5a741998ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af471b3b9cbe820e50ebbb5a741998ca2">&#9670;&#160;</a></span>stream() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::stream </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; detail::stream_element_processor&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize a new stream with the given stream processor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">processor</td><td>The initial stream processor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8f1b44b66138d284100d696969b2c321" name="a8f1b44b66138d284100d696969b2c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1b44b66138d284100d696969b2c321">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::all </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all elements of the stream matches the given predicate.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all elements matches </dd></dl>

</div>
</div>
<a id="a5090ba06d89077916a744d781747824d" name="a5090ba06d89077916a744d781747824d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5090ba06d89077916a744d781747824d">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::any </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if any element of the stream matches the given predicate.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any element matches </dd></dl>

</div>
</div>
<a id="a591c3a36bb085dd4252459f7bfd4d68c" name="a591c3a36bb085dd4252459f7bfd4d68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591c3a36bb085dd4252459f7bfd4d68c">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an element at the given position index. The value is returned as an optional because the requested position could be invalid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Position of the requested element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional possibly containing the value. </dd></dl>

</div>
</div>
<a id="ad6d9ec3cef6dab4d0e7946fc4e06d78f" name="ad6d9ec3cef6dab4d0e7946fc4e06d78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d9ec3cef6dab4d0e7946fc4e06d78f">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt;<a class="el" href="classmatador_1_1stream.html#a638b752bc6d35c488a72f5cc8f44c062">::iterator</a> <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the begin iterator of the stream</p>
<dl class="section return"><dt>Returns</dt><dd>Begin iterator of the stream </dd></dl>

</div>
</div>
<a id="a862808f6663bd3d9e75c5c36a256b68e" name="a862808f6663bd3d9e75c5c36a256b68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862808f6663bd3d9e75c5c36a256b68e">&#9670;&#160;</a></span>collect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;template&lt; class ... &gt; class C, class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C&lt; T, Allocator &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::collect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The collect method collects all elements into new container of type C. The containers template parameters are the type T and an allocator type Allocator. The default for the allocator is std::allocator&lt;T&gt;</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>Type of the container </td></tr>
    <tr><td class="paramname">Allocator</td><td>Allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The container containing all elements </dd></dl>

</div>
</div>
<a id="a935df5c1f1ecf3f5647485d534bb7a5f" name="a935df5c1f1ecf3f5647485d534bb7a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935df5c1f1ecf3f5647485d534bb7a5f">&#9670;&#160;</a></span>collect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;template&lt; class ... &gt; class C, class Key , class Value , typename KeyFunc , typename ValueFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C&lt; Key, Value &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::collect </td>
          <td>(</td>
          <td class="paramtype">const KeyFunc &amp;&#160;</td>
          <td class="paramname"><em>key_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueFunc &amp;&#160;</td>
          <td class="paramname"><em>value_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The collect method collects all elements into new associative container of type C. The containers template parameters are the type Key and Value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>Type of the container </td></tr>
    <tr><td class="paramname">Key</td><td>Key type of the associative container </td></tr>
    <tr><td class="paramname">Value</td><td>Value type of the associative container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyFunc</td><td>The function returning the key </td></tr>
    <tr><td class="paramname">valueFunc</td><td>The function returning the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An associative container containing all transformed elements </dd></dl>

</div>
</div>
<a id="a38ba287ce0b13c7d565a821c7e7a24c6" name="a38ba287ce0b13c7d565a821c7e7a24c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ba287ce0b13c7d565a821c7e7a24c6">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenates the current stream with the given stream of the same type. Once the current stream finishes the elements of the next stream are processed seamlessly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The stream to concatenate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enhanced stream </dd></dl>

</div>
</div>
<a id="afa79755850ea6e1e79168038f4da5d24" name="afa79755850ea6e1e79168038f4da5d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa79755850ea6e1e79168038f4da5d24">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements in the stream</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements </dd></dl>

</div>
</div>
<a id="a2a3251274c643e357398783b2099dcbf" name="a2a3251274c643e357398783b2099dcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3251274c643e357398783b2099dcbf">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of elements matching the given predicate.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matching elements </dd></dl>

</div>
</div>
<a id="adfcf7abbad0decbec0dbf767cabe35ae" name="adfcf7abbad0decbec0dbf767cabe35ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcf7abbad0decbec0dbf767cabe35ae">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt;<a class="el" href="classmatador_1_1stream.html#a638b752bc6d35c488a72f5cc8f44c062">::iterator</a> <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the end iterator of the stream</p>
<dl class="section return"><dt>Returns</dt><dd>End iterator of the stream </dd></dl>

</div>
</div>
<a id="a168df705ec02d4bfd18d488de9db66cd" name="a168df705ec02d4bfd18d488de9db66cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168df705ec02d4bfd18d488de9db66cd">&#9670;&#160;</a></span>every()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::every </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns every nth elements of the stream identified by the given count</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Identifies which elements are valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enhanced stream </dd></dl>

</div>
</div>
<a id="afdf66f571e273e987c5d741c3a1b581c" name="afdf66f571e273e987c5d741c3a1b581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf66f571e273e987c5d741c3a1b581c">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters the stream by the given predicate. Only if the predicate called with the current element evaluates to true the element is valid</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enhanced stream </dd></dl>

</div>
</div>
<a id="ab34505bd3cfe4f45f0d544c90dc66f1e" name="ab34505bd3cfe4f45f0d544c90dc66f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34505bd3cfe4f45f0d544c90dc66f1e">&#9670;&#160;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the first element of the current processed stream. The element is returned as an optional because it can be not available.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional possibly containing the first element. </dd></dl>

</div>
</div>
<a id="a8377c841563a76860d4738b73891a9f8" name="a8377c841563a76860d4738b73891a9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8377c841563a76860d4738b73891a9f8">&#9670;&#160;</a></span>flatmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; R &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::flatmap </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flattens a nested container (list, vectors, i.e.) of an element type into one new stream containing all elements of the container</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
    <tr><td class="paramname">R</td><td>Return type of the predicate and type of the new stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Predicate to apply on every stream element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New stream created of the result of given predicate </dd></dl>

</div>
</div>
<a id="af8412764b48de693f575d76926dc9293" name="af8412764b48de693f575d76926dc9293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8412764b48de693f575d76926dc9293">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over all stream elements and applies the given predicate to each element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Function to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6355983303d93fcbcd9d8353b97877f" name="ae6355983303d93fcbcd9d8353b97877f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6355983303d93fcbcd9d8353b97877f">&#9670;&#160;</a></span>join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Joins all stream elements into one string.</p>
<dl class="section return"><dt>Returns</dt><dd>All stream elements in one string </dd></dl>

</div>
</div>
<a id="a11840a4307c62b91a3c911d2e5f3ce85" name="a11840a4307c62b91a3c911d2e5f3ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11840a4307c62b91a3c911d2e5f3ce85">&#9670;&#160;</a></span>join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Joins all stream elements delimited by the given delimiter into one string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>Delimiter for the elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All stream elements in one string </dd></dl>

</div>
</div>
<a id="ac72db81fa355ad662509ec1b752b4dac" name="ac72db81fa355ad662509ec1b752b4dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72db81fa355ad662509ec1b752b4dac">&#9670;&#160;</a></span>join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Joins all stream elements delimited by the given delimiter into one string. Additionally a prefix and a suffix is prepended and appended to the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>Delimiter for the elements </td></tr>
    <tr><td class="paramname">prefix</td><td>Prefix for the string </td></tr>
    <tr><td class="paramname">suffix</td><td>Suffix for the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All stream elements in one string </dd></dl>

</div>
</div>
<a id="a6d792b455ffea60ef118bddd137923f9" name="a6d792b455ffea60ef118bddd137923f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d792b455ffea60ef118bddd137923f9">&#9670;&#160;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last element of the current processed stream. The element is returned as an optional because it can be not available.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional possibly containing the last element. </dd></dl>

</div>
</div>
<a id="af60e946011fffcf841d778cfea0ea8cf" name="af60e946011fffcf841d778cfea0ea8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60e946011fffcf841d778cfea0ea8cf">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; R &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps each element of stream to new element creating a new stream of elements. This stream could be of the same type as the origin stream or of a new type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
    <tr><td class="paramname">R</td><td>Return type of the predicate and type of the new stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Predicate to apply on every stream element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New stream created of the result of given predicate </dd></dl>

</div>
</div>
<a id="ada936bc6b5ea90cdf2b30c93d41dc20a" name="ada936bc6b5ea90cdf2b30c93d41dc20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada936bc6b5ea90cdf2b30c93d41dc20a">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum of the stream. This value is calculated using the std::less algorithm. The return value is an optional because the stream could be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional possibly containing the maximum value. </dd></dl>

</div>
</div>
<a id="aea700c32b4ee12577e27374be474291b" name="aea700c32b4ee12577e27374be474291b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea700c32b4ee12577e27374be474291b">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum of the stream. This value is calculated using the std::less algorithm. The return value is an optional because the stream could be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional possibly containing the minimum value. </dd></dl>

</div>
</div>
<a id="a3f9fad71791eadee9171f1dbca458ae7" name="a3f9fad71791eadee9171f1dbca458ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9fad71791eadee9171f1dbca458ae7">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::none </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if none of the elements of the stream matches the given predicate.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if none element matches </dd></dl>

</div>
</div>
<a id="a84907f6a4ee736c427ce0c642991d9ec" name="a84907f6a4ee736c427ce0c642991d9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84907f6a4ee736c427ce0c642991d9ec">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; detail::stream_element_processor&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new stream by assigning a given stream processor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">processor</td><td>Stream processor to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assigned stream </dd></dl>

</div>
</div>
<a id="a76894fbc9183825ecf24a2b4466c27a0" name="a76894fbc9183825ecf24a2b4466c27a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76894fbc9183825ecf24a2b4466c27a0">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a> &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assigns stream from given stream x</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Stream to copy assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The copy assigned stream </dd></dl>

</div>
</div>
<a id="a64672af4acc2a41277130a48b81a0cd1" name="a64672af4acc2a41277130a48b81a0cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64672af4acc2a41277130a48b81a0cd1">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a> &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign move stream from given stream x</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Stream to assign move from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assign moved stream </dd></dl>

</div>
</div>
<a id="ae0735b5a00a6d78259fe15d7b778575d" name="ae0735b5a00a6d78259fe15d7b778575d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0735b5a00a6d78259fe15d7b778575d">&#9670;&#160;</a></span>pack_every()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; std::vector&lt; T &gt; &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::pack_every </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>packsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack every n elemets of the stream into a container (vector) and create a ne wstream of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packsize</td><td>Number of elements to pack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stream of packed elements </dd></dl>

</div>
</div>
<a id="a4f16bccfeb2c4f75b00e7a37cd0a7d8e" name="a4f16bccfeb2c4f75b00e7a37cd0a7d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f16bccfeb2c4f75b00e7a37cd0a7d8e">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Peeks each valid element with the given predicate. This processor can be used to check or debug each stream element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enhanced stream </dd></dl>

</div>
</div>
<a id="a13beb5bed8c26a4a5d7ac7493bac148c" name="a13beb5bed8c26a4a5d7ac7493bac148c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13beb5bed8c26a4a5d7ac7493bac148c">&#9670;&#160;</a></span>print_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::print_to </td>
          <td>(</td>
          <td class="paramtype">std::ostream&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints all elements of the stream to the given std::ostream. The elements are separated by the given delimiter string. The default delimiter is a blank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The ostream to write to </td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter for the elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44e56fc6aac6c731a09b791b6cd97803" name="a44e56fc6aac6c731a09b791b6cd97803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e56fc6aac6c731a09b791b6cd97803">&#9670;&#160;</a></span>processor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; detail::stream_element_processor&lt; T &gt; &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::processor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current sentinel processor of the stream This processor represents the last stream processor and contains its successor to ensure a valid processing chain for each element.</p>
<dl class="section return"><dt>Returns</dt><dd>The sentinel stream element processor </dd></dl>

</div>
</div>
<a id="a00cfcf09a9dc7b003a80c7256c599811" name="a00cfcf09a9dc7b003a80c7256c599811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cfcf09a9dc7b003a80c7256c599811">&#9670;&#160;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Accumulator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Accumulator &amp;&amp;&#160;</td>
          <td class="paramname"><em>accu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All elements of the stream are reduced to one element using the given accumulator function. This function takes the current element and the current accumulated value and returns the new accumulated value. The returned value is an optional because the stream could be empty and thus the result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Accumulator</td><td>Type of the accumulator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accu</td><td>The accumulator function to be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional possibly containing the accumulated value. </dd></dl>

</div>
</div>
<a id="a55cbb87cb80a40ce1f317d28c0ed91b2" name="a55cbb87cb80a40ce1f317d28c0ed91b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cbb87cb80a40ce1f317d28c0ed91b2">&#9670;&#160;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename Accumulator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accumulator &amp;&amp;&#160;</td>
          <td class="paramname"><em>accu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All elements of the stream are reduced to one element using the given accumulator function. This function takes the current element and the current accumulated value and returns the new accumulated value. The initial value for this reduction is the given identity value. If the stream is empty, at least this value is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Type of the return and identity value </td></tr>
    <tr><td class="paramname">Accumulator</td><td>Type of the accumulator function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identity</td><td>Initial value </td></tr>
    <tr><td class="paramname">accu</td><td>The accumulator function to be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value, at least the given identity value </dd></dl>

</div>
</div>
<a id="a28f0b951edda866b3c40caa5c0e25d14" name="a28f0b951edda866b3c40caa5c0e25d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f0b951edda866b3c40caa5c0e25d14">&#9670;&#160;</a></span>reduce_idfunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename Accumulator , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1optional.html">optional</a>&lt; R &gt; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::reduce_idfunc </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>identity_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accumulator &amp;&amp;&#160;</td>
          <td class="paramname"><em>accu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All elements of the stream are reduced to one element using the given accumulator function. This function takes the current element and the current accumulated value and returns the new accumulated value. To create the initial value the given identity function is used. The returned value is an optional because the stream could be empty and thus the result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Type of the identity function </td></tr>
    <tr><td class="paramname">Accumulator</td><td>Type of the accumulator function </td></tr>
    <tr><td class="paramname">R</td><td>Type of the returned value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identity_fun</td><td>Function to create the initial value </td></tr>
    <tr><td class="paramname">accu</td><td>The accumulator function to be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional possibly containing the accumulated value. </dd></dl>

</div>
</div>
<a id="a5164896b4ebe3fd1fe7b601f232dc1c1" name="a5164896b4ebe3fd1fe7b601f232dc1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5164896b4ebe3fd1fe7b601f232dc1c1">&#9670;&#160;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skip the first number elements of the stream defined by the given count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of elements to skip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enhanced stream </dd></dl>

</div>
</div>
<a id="a57b53414bfe2f25c23ae2dbfc6fb937d" name="a57b53414bfe2f25c23ae2dbfc6fb937d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b53414bfe2f25c23ae2dbfc6fb937d">&#9670;&#160;</a></span>skip_while()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::skip_while </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skip elements of the stream while given predicate is true. Once the predicate gets false the capacity elements are valid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enhanced stream </dd></dl>

</div>
</div>
<a id="a29052a25033bdee7d191cf9b705096a6" name="a29052a25033bdee7d191cf9b705096a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29052a25033bdee7d191cf9b705096a6">&#9670;&#160;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::take </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take only count elements of the data stream. Than the stream id finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of elements to be taken </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream enhanced with the take processor. </dd></dl>

</div>
</div>
<a id="a9fefc80ac3285932cad80de552f35a81" name="a9fefc80ac3285932cad80de552f35a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fefc80ac3285932cad80de552f35a81">&#9670;&#160;</a></span>take_while()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1stream.html">stream</a>&lt; T &gt; &amp; <a class="el" href="classmatador_1_1stream.html">matador::stream</a>&lt; T &gt;::take_while </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take only elements of the stream as long as the given predicate if true</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Type of the predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Condition to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enhanced stream </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>matador/utils/<b>stream.hpp</b></li>
</ul>
</div><!-- contents -->
