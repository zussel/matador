---
layout: reference
title: matador::object_store Class Reference
---
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematador.html">matador</a></li><li class="navelem"><a class="el" href="classmatador_1_1object__store.html">object_store</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classmatador_1_1object__store-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">matador::object_store Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that stores all kind of objects.  
 <a href="classmatador_1_1object__store.html#details">More...</a></p>

<p><code>#include &lt;object_store.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a90dd6de414a4bd03459407a163dff40c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40c">abstract_type</a> { <a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40ca7cef45752b002d81f52c25af32cb3c0a">abstract</a>, 
<a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40ca514c34b6c56d3be8f472f3002ad60e84">not_abstract</a>
 }</td></tr>
<tr class="separator:a90dd6de414a4bd03459407a163dff40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a123215d64159afe7b742b95c5c0d7"><td class="memItemLeft" align="right" valign="top">typedef prototype_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a></td></tr>
<tr class="separator:ab2a123215d64159afe7b742b95c5c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b78f428075ffe0b231f93c063db7f8"><td class="memItemLeft" align="right" valign="top">typedef const_prototype_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a></td></tr>
<tr class="separator:ab3b78f428075ffe0b231f93c063db7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3160cf969b8aeb02ec1fb748fee58518"><td class="memItemLeft" align="right" valign="top"><a id="a3160cf969b8aeb02ec1fb748fee58518"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>object_store</b> (const <a class="el" href="classmatador_1_1object__store.html">object_store</a> &amp;)=delete</td></tr>
<tr class="separator:a3160cf969b8aeb02ec1fb748fee58518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679cc6cb5831ba01706de78806cc8078"><td class="memItemLeft" align="right" valign="top"><a id="a679cc6cb5831ba01706de78806cc8078"></a>
<a class="el" href="classmatador_1_1object__store.html">object_store</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmatador_1_1object__store.html">object_store</a> &amp;)=delete</td></tr>
<tr class="separator:a679cc6cb5831ba01706de78806cc8078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17511ba7697ce7b57da968e204b849b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ad17511ba7697ce7b57da968e204b849b">object_store</a> ()</td></tr>
<tr class="separator:ad17511ba7697ce7b57da968e204b849b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eff3fb1b0d6eca8d06cd55c726c0462"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a6eff3fb1b0d6eca8d06cd55c726c0462">~object_store</a> ()</td></tr>
<tr class="separator:a6eff3fb1b0d6eca8d06cd55c726c0462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455a81af2ed9afe238bf1e9fe5869721"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a455a81af2ed9afe238bf1e9fe5869721"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a455a81af2ed9afe238bf1e9fe5869721">attach</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>, const char *parent=nullptr)</td></tr>
<tr class="separator:a455a81af2ed9afe238bf1e9fe5869721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436240f2c50879c9b9ac38eb17c42170"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a436240f2c50879c9b9ac38eb17c42170"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a436240f2c50879c9b9ac38eb17c42170">attach_abstract</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>, const char *parent=nullptr)</td></tr>
<tr class="separator:a436240f2c50879c9b9ac38eb17c42170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0153783e81839b01391202e1ecf1a94"><td class="memTemplParams" colspan="2">template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:ab0153783e81839b01391202e1ecf1a94"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ab0153783e81839b01391202e1ecf1a94">attach</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>)</td></tr>
<tr class="separator:ab0153783e81839b01391202e1ecf1a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5affaaf9adef297c130c11a66c909b46"><td class="memTemplParams" colspan="2">template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:a5affaaf9adef297c130c11a66c909b46"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a5affaaf9adef297c130c11a66c909b46">attach_abstract</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>)</td></tr>
<tr class="separator:a5affaaf9adef297c130c11a66c909b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d9cc7b19828c7a532d41bd3feaf14c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70d9cc7b19828c7a532d41bd3feaf14c"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a70d9cc7b19828c7a532d41bd3feaf14c">attach</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>, <a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40c">abstract_type</a> <a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40ca7cef45752b002d81f52c25af32cb3c0a">abstract</a>, const char *parent)</td></tr>
<tr class="separator:a70d9cc7b19828c7a532d41bd3feaf14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b7ea038eaf044d6d7c673da8f82129"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class U=T &gt; class O&gt; </td></tr>
<tr class="memitem:a72b7ea038eaf044d6d7c673da8f82129"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a72b7ea038eaf044d6d7c673da8f82129">attach</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>, std::initializer_list&lt; O&lt; T &gt; * &gt; observer)</td></tr>
<tr class="separator:a72b7ea038eaf044d6d7c673da8f82129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4630749935b7aa28f1b958a92fff2df"><td class="memTemplParams" colspan="2">template&lt;class T , class S , template&lt; class U=T &gt; class O&gt; </td></tr>
<tr class="memitem:ab4630749935b7aa28f1b958a92fff2df"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ab4630749935b7aa28f1b958a92fff2df">attach</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>, std::initializer_list&lt; O&lt; T &gt; * &gt; observer)</td></tr>
<tr class="separator:ab4630749935b7aa28f1b958a92fff2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f9b42bc709c1670ad401faba0b59ed"><td class="memTemplParams" colspan="2">template&lt;class T , class S , template&lt; class U=T &gt; class O&gt; </td></tr>
<tr class="memitem:aa5f9b42bc709c1670ad401faba0b59ed"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#aa5f9b42bc709c1670ad401faba0b59ed">attach_abstract</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>, std::initializer_list&lt; O&lt; T &gt; * &gt; observer)</td></tr>
<tr class="separator:aa5f9b42bc709c1670ad401faba0b59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5979ef7994145133aefe7a9137804e"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class U=T &gt; class O&gt; </td></tr>
<tr class="memitem:afb5979ef7994145133aefe7a9137804e"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#afb5979ef7994145133aefe7a9137804e">attach</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>, <a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40c">abstract_type</a> <a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40ca7cef45752b002d81f52c25af32cb3c0a">abstract</a>, const char *parent, std::initializer_list&lt; O&lt; T &gt; * &gt; observer)</td></tr>
<tr class="separator:afb5979ef7994145133aefe7a9137804e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b62145e327822988fd2418139332192"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class U=T &gt; class O&gt; </td></tr>
<tr class="memitem:a0b62145e327822988fd2418139332192"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a0b62145e327822988fd2418139332192">attach</a> (<a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *node, const char *parent, std::initializer_list&lt; O&lt; T &gt; * &gt; observer)</td></tr>
<tr class="separator:a0b62145e327822988fd2418139332192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25dffe36cf3b7c96af08d2d0b4b2344"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class U=T &gt; class O&gt; </td></tr>
<tr class="memitem:aa25dffe36cf3b7c96af08d2d0b4b2344"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#aa25dffe36cf3b7c96af08d2d0b4b2344">attach</a> (<a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *node, std::initializer_list&lt; O&lt; T &gt; * &gt; observer)</td></tr>
<tr class="separator:aa25dffe36cf3b7c96af08d2d0b4b2344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fb53eef931cdd1c2db47e36604be00"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0fb53eef931cdd1c2db47e36604be00"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ae0fb53eef931cdd1c2db47e36604be00">attach</a> (<a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *node, const char *parent=nullptr)</td></tr>
<tr class="separator:ae0fb53eef931cdd1c2db47e36604be00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42305b18f9fcf46d7987cd60361e44ea"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class U=T &gt; class O&gt; </td></tr>
<tr class="memitem:a42305b18f9fcf46d7987cd60361e44ea"><td class="memTemplItemLeft" align="right" valign="top">prototype_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a42305b18f9fcf46d7987cd60361e44ea">attach_internal</a> (<a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *node, const char *parent, std::vector&lt; O&lt; T &gt; * &gt; observer)</td></tr>
<tr class="separator:a42305b18f9fcf46d7987cd60361e44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fb875eab358f3cdc16afa33edfc344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ad5fb875eab358f3cdc16afa33edfc344">detach</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>)</td></tr>
<tr class="separator:ad5fb875eab358f3cdc16afa33edfc344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677d0f5ce8acf2a32fe818029c099238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a677d0f5ce8acf2a32fe818029c099238">detach</a> (const prototype_iterator &amp;i)</td></tr>
<tr class="separator:a677d0f5ce8acf2a32fe818029c099238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478cb2f115bb06ef933d64db1dabe961"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a478cb2f115bb06ef933d64db1dabe961"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a> () const</td></tr>
<tr class="separator:a478cb2f115bb06ef933d64db1dabe961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e947d644e7c6bb2caea3505e4910760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a2e947d644e7c6bb2caea3505e4910760">find</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>)</td></tr>
<tr class="memdesc:a2e947d644e7c6bb2caea3505e4910760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds prototype node.  <a href="classmatador_1_1object__store.html#a2e947d644e7c6bb2caea3505e4910760">More...</a><br /></td></tr>
<tr class="separator:a2e947d644e7c6bb2caea3505e4910760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ba8feb0c2b8393e940f292ea59e80a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a72ba8feb0c2b8393e940f292ea59e80a">find</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>) const</td></tr>
<tr class="memdesc:a72ba8feb0c2b8393e940f292ea59e80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds prototype node.  <a href="classmatador_1_1object__store.html#a72ba8feb0c2b8393e940f292ea59e80a">More...</a><br /></td></tr>
<tr class="separator:a72ba8feb0c2b8393e940f292ea59e80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc26db05422cccf602dec14fdf8a5c20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afc26db05422cccf602dec14fdf8a5c20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#afc26db05422cccf602dec14fdf8a5c20">find</a> ()</td></tr>
<tr class="memdesc:afc26db05422cccf602dec14fdf8a5c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds prototype node by template type.  <a href="classmatador_1_1object__store.html#afc26db05422cccf602dec14fdf8a5c20">More...</a><br /></td></tr>
<tr class="separator:afc26db05422cccf602dec14fdf8a5c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da0e7c8cdd225b52d295a963ccbed7c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7da0e7c8cdd225b52d295a963ccbed7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a7da0e7c8cdd225b52d295a963ccbed7c">find</a> () const</td></tr>
<tr class="memdesc:a7da0e7c8cdd225b52d295a963ccbed7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds prototype node by template type.  <a href="classmatador_1_1object__store.html#a7da0e7c8cdd225b52d295a963ccbed7c">More...</a><br /></td></tr>
<tr class="separator:a7da0e7c8cdd225b52d295a963ccbed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae3a43cd6a31a9bbf92e4305a4130bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#afae3a43cd6a31a9bbf92e4305a4130bb">begin</a> () const</td></tr>
<tr class="separator:afae3a43cd6a31a9bbf92e4305a4130bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd10a26aa94673a506f88e0599f362d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#abfd10a26aa94673a506f88e0599f362d">begin</a> ()</td></tr>
<tr class="separator:abfd10a26aa94673a506f88e0599f362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42635518bff413bec71fe7dfb4cea8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#af42635518bff413bec71fe7dfb4cea8e">end</a> () const</td></tr>
<tr class="separator:af42635518bff413bec71fe7dfb4cea8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d2bf873eb6afbf417d156feccfe89f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a22d2bf873eb6afbf417d156feccfe89f">end</a> ()</td></tr>
<tr class="separator:a22d2bf873eb6afbf417d156feccfe89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95225e6f81d7b8b03b10960aef7aaaa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a95225e6f81d7b8b03b10960aef7aaaa1">clear</a> (bool full=false)</td></tr>
<tr class="separator:a95225e6f81d7b8b03b10960aef7aaaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2c8743ad95ce5535def35edfc1499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a27c2c8743ad95ce5535def35edfc1499">clear</a> (const char *<a class="el" href="classmatador_1_1object__store.html#a478cb2f115bb06ef933d64db1dabe961">type</a>)</td></tr>
<tr class="separator:a27c2c8743ad95ce5535def35edfc1499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d7badebcc5a38d535af3e5a5a1222a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a64d7badebcc5a38d535af3e5a5a1222a">clear</a> (const prototype_iterator &amp;node)</td></tr>
<tr class="separator:a64d7badebcc5a38d535af3e5a5a1222a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851581e1063a089f27a34991561d1373"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a851581e1063a089f27a34991561d1373">size</a> () const</td></tr>
<tr class="separator:a851581e1063a089f27a34991561d1373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c816e1abea5f88af4bf1443270bd8e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a1c816e1abea5f88af4bf1443270bd8e7">empty</a> () const</td></tr>
<tr class="separator:a1c816e1abea5f88af4bf1443270bd8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04c354bd2c6fef262c0050b770e0534"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae04c354bd2c6fef262c0050b770e0534"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ae04c354bd2c6fef262c0050b770e0534">create</a> () const</td></tr>
<tr class="separator:ae04c354bd2c6fef262c0050b770e0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83c975c9bfe2760e879b6a68677c44d"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:ac83c975c9bfe2760e879b6a68677c44d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ac83c975c9bfe2760e879b6a68677c44d">for_each_root_node</a> (P pred) const</td></tr>
<tr class="separator:ac83c975c9bfe2760e879b6a68677c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1108d1536a4a84442055ceeca59bd1aa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1108d1536a4a84442055ceeca59bd1aa"><td class="memTemplItemLeft" align="right" valign="top">object_proxy *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a1108d1536a4a84442055ceeca59bd1aa">insert</a> (object_proxy *proxy, bool notify)</td></tr>
<tr class="memdesc:a1108d1536a4a84442055ceeca59bd1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new proxy into the object store.  <a href="classmatador_1_1object__store.html#a1108d1536a4a84442055ceeca59bd1aa">More...</a><br /></td></tr>
<tr class="separator:a1108d1536a4a84442055ceeca59bd1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc37c738e392036cb125ff6df256090"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7bc37c738e392036cb125ff6df256090"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a7bc37c738e392036cb125ff6df256090">insert</a> (T *o)</td></tr>
<tr class="separator:a7bc37c738e392036cb125ff6df256090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aec2e11544abb95773fd2e67b488f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae7aec2e11544abb95773fd2e67b488f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ae7aec2e11544abb95773fd2e67b488f4">insert</a> (const <a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;o)</td></tr>
<tr class="separator:ae7aec2e11544abb95773fd2e67b488f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839de40b6bed7fae71b3d2d92e889bc3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a839de40b6bed7fae71b3d2d92e889bc3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a839de40b6bed7fae71b3d2d92e889bc3">is_removable</a> (const <a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;o)</td></tr>
<tr class="separator:a839de40b6bed7fae71b3d2d92e889bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad2d69572e29b0a3e4c8fe4286c3e28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#acad2d69572e29b0a3e4c8fe4286c3e28">remove_proxy</a> (object_proxy *proxy)</td></tr>
<tr class="separator:acad2d69572e29b0a3e4c8fe4286c3e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2325edd1585f3327cd58066cc372b27"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab2325edd1585f3327cd58066cc372b27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ab2325edd1585f3327cd58066cc372b27">remove</a> (object_proxy *proxy, bool check_if_deletable)</td></tr>
<tr class="separator:ab2325edd1585f3327cd58066cc372b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf61c1ee9ff26ed9ac8668e1f7537539"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abf61c1ee9ff26ed9ac8668e1f7537539"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#abf61c1ee9ff26ed9ac8668e1f7537539">remove</a> (<a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;o)</td></tr>
<tr class="separator:abf61c1ee9ff26ed9ac8668e1f7537539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f5e6046813a3ef2601b86b71c556f6"><td class="memItemLeft" align="right" valign="top">object_proxy *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a52f5e6046813a3ef2601b86b71c556f6">find_proxy</a> (unsigned long id) const</td></tr>
<tr class="memdesc:a52f5e6046813a3ef2601b86b71c556f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds serializable proxy with id.  <a href="classmatador_1_1object__store.html#a52f5e6046813a3ef2601b86b71c556f6">More...</a><br /></td></tr>
<tr class="separator:a52f5e6046813a3ef2601b86b71c556f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066dffda1d8099f724763411a7722064"><td class="memItemLeft" align="right" valign="top">object_proxy *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a066dffda1d8099f724763411a7722064">insert_proxy</a> (object_proxy *proxy)</td></tr>
<tr class="separator:a066dffda1d8099f724763411a7722064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97270f2f312f24763e9cfa31e5963264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatador_1_1transaction.html">transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a97270f2f312f24763e9cfa31e5963264">current_transaction</a> ()</td></tr>
<tr class="separator:a97270f2f312f24763e9cfa31e5963264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04069a2904fd9811ac50d27a5e543e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#af04069a2904fd9811ac50d27a5e543e1">has_transaction</a> () const</td></tr>
<tr class="separator:af04069a2904fd9811ac50d27a5e543e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ab9d800b4e80c9e006a4edda38ceb2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a48ab9d800b4e80c9e006a4edda38ceb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#a48ab9d800b4e80c9e006a4edda38ceb2">mark_modified</a> (object_proxy *proxy)</td></tr>
<tr class="separator:a48ab9d800b4e80c9e006a4edda38ceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae022fdb3474ca0178b4c7ce33745c28b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae022fdb3474ca0178b4c7ce33745c28b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ae022fdb3474ca0178b4c7ce33745c28b">mark_modified</a> (const <a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;optr)</td></tr>
<tr class="separator:ae022fdb3474ca0178b4c7ce33745c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad076d64df93f6f0bdfa9dbabcdce0c4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatador_1_1object__store.html#ad076d64df93f6f0bdfa9dbabcdce0c4e">on_proxy_delete</a> (std::function&lt; void(object_proxy *)&gt; callback)</td></tr>
<tr class="separator:ad076d64df93f6f0bdfa9dbabcdce0c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1b5f55b988adcfebfb733f42e8861d2c"><td class="memItemLeft" align="right" valign="top"><a id="a1b5f55b988adcfebfb733f42e8861d2c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::object_inserter</b></td></tr>
<tr class="separator:a1b5f55b988adcfebfb733f42e8861d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5911f0942a0ad046a6f95f3717d6e6f9"><td class="memItemLeft" align="right" valign="top"><a id="a5911f0942a0ad046a6f95f3717d6e6f9"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>detail::basic_relation_endpoint</b></td></tr>
<tr class="separator:a5911f0942a0ad046a6f95f3717d6e6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be0d55351ef8539a57fef1432a6d3f5"><td class="memItemLeft" align="right" valign="top"><a id="a7be0d55351ef8539a57fef1432a6d3f5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>object_serializer</b></td></tr>
<tr class="separator:a7be0d55351ef8539a57fef1432a6d3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1522209290e3b134e0489008ed3e11ea"><td class="memItemLeft" align="right" valign="top"><a id="a1522209290e3b134e0489008ed3e11ea"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>object_holder</b></td></tr>
<tr class="separator:a1522209290e3b134e0489008ed3e11ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de5c7aa317d7bf53dac18959cce2f00"><td class="memItemLeft" align="right" valign="top"><a id="a7de5c7aa317d7bf53dac18959cce2f00"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>object_proxy</b></td></tr>
<tr class="separator:a7de5c7aa317d7bf53dac18959cce2f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edbe5829e90f9367d6b368b2aed9315"><td class="memItemLeft" align="right" valign="top"><a id="a7edbe5829e90f9367d6b368b2aed9315"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>prototype_node</b></td></tr>
<tr class="separator:a7edbe5829e90f9367d6b368b2aed9315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb110e61ed60a3170c870fc944fb3bf"><td class="memItemLeft" align="right" valign="top"><a id="afcb110e61ed60a3170c870fc944fb3bf"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>transaction</b></td></tr>
<tr class="separator:afcb110e61ed60a3170c870fc944fb3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a712ca8fa7a3f2a36b050281d91cb3"><td class="memTemplParams" colspan="2"><a id="a92a712ca8fa7a3f2a36b050281d91cb3"></a>
template&lt;class T , template&lt; class ... &gt; class C&gt; </td></tr>
<tr class="memitem:a92a712ca8fa7a3f2a36b050281d91cb3"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_many</b></td></tr>
<tr class="separator:a92a712ca8fa7a3f2a36b050281d91cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that stores all kind of objects. </p>
<p>This class is the main container class for all objects. To manage the internal list of objects the store must know the serializable class hierarchy.</p>
<p>Therefor an serializable prototype tree holds the serializable hierarchy representation including a producer class serializable of all known types. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab3b78f428075ffe0b231f93c063db7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b78f428075ffe0b231f93c063db7f8">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const_prototype_iterator <a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">matador::object_store::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut for the list const iterator. </p>

</div>
</div>
<a id="ab2a123215d64159afe7b742b95c5c0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a123215d64159afe7b742b95c5c0d7">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef prototype_iterator <a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">matador::object_store::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shortcut for the list iterator. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a90dd6de414a4bd03459407a163dff40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dd6de414a4bd03459407a163dff40c">&#9670;&nbsp;</a></span>abstract_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40c">matador::object_store::abstract_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describes wether the inserted object type is handle as a concrete or abstract type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a90dd6de414a4bd03459407a163dff40ca7cef45752b002d81f52c25af32cb3c0a"></a>abstract&#160;</td><td class="fielddoc"><p>Indicates an abstract object type </p>
</td></tr>
<tr><td class="fieldname"><a id="a90dd6de414a4bd03459407a163dff40ca514c34b6c56d3be8f472f3002ad60e84"></a>not_abstract&#160;</td><td class="fielddoc"><p>Indicates a concrete object type </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad17511ba7697ce7b57da968e204b849b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17511ba7697ce7b57da968e204b849b">&#9670;&nbsp;</a></span>object_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matador::object_store::object_store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an empty serializable store. </p>

</div>
</div>
<a id="a6eff3fb1b0d6eca8d06cd55c726c0462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eff3fb1b0d6eca8d06cd55c726c0462">&#9670;&nbsp;</a></span>~object_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matador::object_store::~object_store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all prototypes, objects and observers in store. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0153783e81839b01391202e1ecf1a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0153783e81839b01391202e1ecf1a94">&#9670;&nbsp;</a></span>attach() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new concrete object prototype into the prototype tree. The prototype consists of a unique type name.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">S</td><td>The type of the parent prototype node </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The unique name of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="a70d9cc7b19828c7a532d41bd3feaf14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d9cc7b19828c7a532d41bd3feaf14c">&#9670;&nbsp;</a></span>attach() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40c">abstract_type</a>&#160;</td>
          <td class="paramname"><em>abstract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the abstract flag is true prototype is treated as abstract. No concrete object can be inserted for this prototype.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The unique name of the type. </td></tr>
    <tr><td class="paramname">abstract</td><td>Indicates if the producers serializable is treated as an abstract node. </td></tr>
    <tr><td class="paramname">parent</td><td>Name of the parent node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="afb5979ef7994145133aefe7a9137804e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5979ef7994145133aefe7a9137804e">&#9670;&nbsp;</a></span>attach() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class U=T &gt; class O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatador_1_1object__store.html#a90dd6de414a4bd03459407a163dff40c">abstract_type</a>&#160;</td>
          <td class="paramname"><em>abstract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; O&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new abstract object prototype into the prototype tree. The prototype consists of a unique type name.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">O</td><td>The type of the observer classes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The unique name of the type. </td></tr>
    <tr><td class="paramname">abstract</td><td>Indicates weather type is abstract or not </td></tr>
    <tr><td class="paramname">parent</td><td>The name of the parent node. </td></tr>
    <tr><td class="paramname">observer</td><td>A list of observer to be called an attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="a455a81af2ed9afe238bf1e9fe5869721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455a81af2ed9afe238bf1e9fe5869721">&#9670;&nbsp;</a></span>attach() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new concrete object prototype into the <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a>. The prototype consists of a unique type name. The type of the prototype is given via template parameter T. If parent name is given prototype node is inserted below the found parent node.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the prototype </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Name of the prototype </td></tr>
    <tr><td class="paramname">parent</td><td>Name of the parent node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator representing the inserted prototype node </dd></dl>

</div>
</div>
<a id="a72b7ea038eaf044d6d7c673da8f82129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b7ea038eaf044d6d7c673da8f82129">&#9670;&nbsp;</a></span>attach() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class U=T &gt; class O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; O&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new concrete object prototype into the prototype tree. The prototype consists of a unique type name.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">O</td><td>The type of the observer classes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The unique name of the type. </td></tr>
    <tr><td class="paramname">observer</td><td>A list of observer to be called an attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="ab4630749935b7aa28f1b958a92fff2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4630749935b7aa28f1b958a92fff2df">&#9670;&nbsp;</a></span>attach() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S , template&lt; class U=T &gt; class O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; O&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new concrete object prototype into the prototype tree. The prototype consists of a unique type name.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">S</td><td>The type of the parent prototype node </td></tr>
    <tr><td class="paramname">O</td><td>The type of the observer classes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The unique name of the type. </td></tr>
    <tr><td class="paramname">observer</td><td>A list of observer to be called an attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="a0b62145e327822988fd2418139332192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b62145e327822988fd2418139332192">&#9670;&nbsp;</a></span>attach() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class U=T &gt; class O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; O&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new object prototype into the <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a>. The type of the prototype is given via template parameter T. A prepared prototype node is passed to be inserted. If parent name is given prototype node is inserted below the found parent node.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">O</td><td>The type of the observer classes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The prototype node to be inserted </td></tr>
    <tr><td class="paramname">parent</td><td>The name of the parent node. </td></tr>
    <tr><td class="paramname">observer</td><td>A list of observer to be called an attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="ae0fb53eef931cdd1c2db47e36604be00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fb53eef931cdd1c2db47e36604be00">&#9670;&nbsp;</a></span>attach() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new object prototype into the <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a>. The type of the prototype is given via template parameter T. A prepared prototype node is passed to be inserted. If parent name is given prototype node is inserted below the found parent node.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The prototype node to be inserted </td></tr>
    <tr><td class="paramname">parent</td><td>The name of the parent node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="aa25dffe36cf3b7c96af08d2d0b4b2344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25dffe36cf3b7c96af08d2d0b4b2344">&#9670;&nbsp;</a></span>attach() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class U=T &gt; class O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; O&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new object prototype into the <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a> as a root object type. The type of the prototype is given via template parameter T. A prepared prototype node is passed to be inserted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">O</td><td>The type of the observer classes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The prototype node to be inserted </td></tr>
    <tr><td class="paramname">observer</td><td>A list of observer to be called an attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="a5affaaf9adef297c130c11a66c909b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5affaaf9adef297c130c11a66c909b46">&#9670;&nbsp;</a></span>attach_abstract() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach_abstract </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new abstract object prototype into the prototype tree. The prototype consists of a unique type name.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">S</td><td>The type of the parent prototype node </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The unique name of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="a436240f2c50879c9b9ac38eb17c42170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436240f2c50879c9b9ac38eb17c42170">&#9670;&nbsp;</a></span>attach_abstract() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach_abstract </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new abstract object prototype into the <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a>. The prototype consists of a unique type name. The type of the prototype is given via template parameter T. If parent name is given prototype node is inserted below the found parent node.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the prototype </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Name of the prototype </td></tr>
    <tr><td class="paramname">parent</td><td>Name of the parent node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator representing the inserted prototype node </dd></dl>

</div>
</div>
<a id="aa5f9b42bc709c1670ad401faba0b59ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f9b42bc709c1670ad401faba0b59ed">&#9670;&nbsp;</a></span>attach_abstract() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S , template&lt; class U=T &gt; class O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach_abstract </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; O&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new abstract object prototype into the prototype tree. The prototype consists of a unique type name.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">S</td><td>The type of the parent prototype node </td></tr>
    <tr><td class="paramname">O</td><td>The type of the observer classes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The unique name of the type. </td></tr>
    <tr><td class="paramname">observer</td><td>A list of observer to be called an attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="a42305b18f9fcf46d7987cd60361e44ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42305b18f9fcf46d7987cd60361e44ea">&#9670;&nbsp;</a></span>attach_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class U=T &gt; class O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">prototype_iterator matador::object_store::attach_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatador_1_1prototype__node.html">prototype_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; O&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new object prototype into the <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a> as a root object type. The type of the prototype is given via template parameter T. A prepared prototype node is passed to be inserted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the prototype node </td></tr>
    <tr><td class="paramname">O</td><td>The type of the observer classes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The prototype node to be inserted </td></tr>
    <tr><td class="paramname">parent</td><td>The name of the parent node. </td></tr>
    <tr><td class="paramname">observer</td><td>A list of observer to be called an attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new inserted prototype iterator. </dd></dl>

</div>
</div>
<a id="abfd10a26aa94673a506f88e0599f362d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd10a26aa94673a506f88e0599f362d">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a> matador::object_store::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the first prototype node.</p>
<dl class="section return"><dt>Returns</dt><dd>The first prototype node iterator. </dd></dl>

</div>
</div>
<a id="afae3a43cd6a31a9bbf92e4305a4130bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae3a43cd6a31a9bbf92e4305a4130bb">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a> matador::object_store::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the first prototype node.</p>
<dl class="section return"><dt>Returns</dt><dd>The first prototype node iterator. </dd></dl>

</div>
</div>
<a id="a95225e6f81d7b8b03b10960aef7aaaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95225e6f81d7b8b03b10960aef7aaaa1">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all inserted prototypes and all inserted objects. </p>

</div>
</div>
<a id="a27c2c8743ad95ce5535def35edfc1499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2c8743ad95ce5535def35edfc1499">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::clear </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears a prototype node and its cildren nodes. All objects will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The name of the type to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmatador_1_1object__exception.html" title="An serializable exception class.">matador::object_exception</a></td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d7badebcc5a38d535af3e5a5a1222a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d7badebcc5a38d535af3e5a5a1222a">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::clear </td>
          <td>(</td>
          <td class="paramtype">const prototype_iterator &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears a prototype node by an iterator and its children nodes. All object_proxy objects will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The prototype_iterator to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmatador_1_1object__exception.html" title="An serializable exception class.">matador::object_exception</a></td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae04c354bd2c6fef262c0050b770e0534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04c354bd2c6fef262c0050b770e0534">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* matador::object_store::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an serializable of the given type name.</p>
<dl class="section return"><dt>Returns</dt><dd>The created serializable on success or NULL if the type couldn't be found. </dd></dl>

</div>
</div>
<a id="a97270f2f312f24763e9cfa31e5963264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97270f2f312f24763e9cfa31e5963264">&#9670;&nbsp;</a></span>current_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1transaction.html">transaction</a> matador::object_store::current_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the current transaction in stack</p>
<dl class="section return"><dt>Returns</dt><dd>The current transaction in stack </dd></dl>

</div>
</div>
<a id="ad5fb875eab358f3cdc16afa33edfc344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fb875eab358f3cdc16afa33edfc344">&#9670;&nbsp;</a></span>detach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::detach </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an object prototype from the prototype tree. All children nodes and all objects are also removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The name of the type to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a677d0f5ce8acf2a32fe818029c099238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677d0f5ce8acf2a32fe818029c099238">&#9670;&nbsp;</a></span>detach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a> matador::object_store::detach </td>
          <td>(</td>
          <td class="paramtype">const prototype_iterator &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase a prototype node identified by its iterator. The successor iterator is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The prototype iterator to be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The successor of the erased iterator </dd></dl>

</div>
</div>
<a id="a1c816e1abea5f88af4bf1443270bd8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c816e1abea5f88af4bf1443270bd8e7">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matador::object_store::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a> conatins no elements (objects)</p>
<dl class="section return"><dt>Returns</dt><dd>True on empty <a class="el" href="classmatador_1_1object__store.html" title="A class that stores all kind of objects.">object_store</a>. </dd></dl>

</div>
</div>
<a id="a22d2bf873eb6afbf417d156feccfe89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d2bf873eb6afbf417d156feccfe89f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a> matador::object_store::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last prototype node.</p>
<dl class="section return"><dt>Returns</dt><dd>The last prototype node iterator. </dd></dl>

</div>
</div>
<a id="af42635518bff413bec71fe7dfb4cea8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42635518bff413bec71fe7dfb4cea8e">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a> matador::object_store::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last prototype node.</p>
<dl class="section return"><dt>Returns</dt><dd>The last prototype node iterator. </dd></dl>

</div>
</div>
<a id="afc26db05422cccf602dec14fdf8a5c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc26db05422cccf602dec14fdf8a5c20">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a> matador::object_store::find </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds prototype node by template type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Template</td><td>type.</td></tr>
  </table>
  </dd>
</dl>
<p>Finds and returns prototype node iterator identified by the given template typeid. If the prototype couldn't be found prototype_iterator end is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a prototype iterator. </dd></dl>

</div>
</div>
<a id="a7da0e7c8cdd225b52d295a963ccbed7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da0e7c8cdd225b52d295a963ccbed7c">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a> matador::object_store::find </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds prototype node by template type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Template</td><td>type.</td></tr>
  </table>
  </dd>
</dl>
<p>Finds and returns prototype node iterator identified by the given template typeid. If the prototype couldn't be found prototype_iterator end is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a prototype iterator. </dd></dl>

</div>
</div>
<a id="a2e947d644e7c6bb2caea3505e4910760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e947d644e7c6bb2caea3505e4910760">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab2a123215d64159afe7b742b95c5c0d7">iterator</a> matador::object_store::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds prototype node. </p>
<p>Finds and returns prototype node iterator identified by the given name or classname (typeid). If the prototype couldn't be found prototype_iterator end is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Name or class name of the prototype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a prototype iterator. </dd></dl>

</div>
</div>
<a id="a72ba8feb0c2b8393e940f292ea59e80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ba8feb0c2b8393e940f292ea59e80a">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatador_1_1object__store.html#ab3b78f428075ffe0b231f93c063db7f8">const_iterator</a> matador::object_store::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds prototype node. </p>
<p>Finds and returns prototype node iterator identified by the given name or classname (typeid). If the prototype couldn't be found prototype_iterator end is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Name or class name of the prototype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a prototype iterator. </dd></dl>

</div>
</div>
<a id="a52f5e6046813a3ef2601b86b71c556f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f5e6046813a3ef2601b86b71c556f6">&#9670;&nbsp;</a></span>find_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">object_proxy* matador::object_store::find_proxy </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds serializable proxy with id. </p>
<p>Try to find the serializable proxy with given id in serializable stores proxy map. If serializable can't be found NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of serializable proxy to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success it returns an serializable proxy on failure null </dd></dl>

</div>
</div>
<a id="ac83c975c9bfe2760e879b6a68677c44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83c975c9bfe2760e879b6a68677c44d">&#9670;&nbsp;</a></span>for_each_root_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::for_each_root_node </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes a predicate for each root node</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The type of the predicate function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>The function object to be executed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af04069a2904fd9811ac50d27a5e543e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04069a2904fd9811ac50d27a5e543e1">&#9670;&nbsp;</a></span>has_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matador::object_store::has_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there is at least one transaction on stack.</p>
<dl class="section return"><dt>Returns</dt><dd>True if there at least one transaction. </dd></dl>

</div>
</div>
<a id="ae7aec2e11544abb95773fd2e67b488f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aec2e11544abb95773fd2e67b488f4">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt;T&gt; matador::object_store::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a given object_ptr of specific type. On successfull insertion an object_ptr element with the inserted object is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object_ptr to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inserted object contained by an object_ptr on success. </dd></dl>

</div>
</div>
<a id="a1108d1536a4a84442055ceeca59bd1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1108d1536a4a84442055ceeca59bd1aa">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">object_proxy* matador::object_store::insert </td>
          <td>(</td>
          <td class="paramtype">object_proxy *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new proxy into the object store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Object proxy to insert </td></tr>
    <tr><td class="paramname">notify</td><td>Indicates wether all observers should be notified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bc37c738e392036cb125ff6df256090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc37c738e392036cb125ff6df256090">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt;T&gt; matador::object_store::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts an object of a specfic type. On successfull insertion an object_ptr element with the inserted object is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Object to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inserted object contained by an object_ptr on success. </dd></dl>

</div>
</div>
<a id="a066dffda1d8099f724763411a7722064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066dffda1d8099f724763411a7722064">&#9670;&nbsp;</a></span>insert_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">object_proxy* matador::object_store::insert_proxy </td>
          <td>(</td>
          <td class="paramtype">object_proxy *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert object proxy into object store Object id must be set </p>

</div>
</div>
<a id="a839de40b6bed7fae71b3d2d92e889bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839de40b6bed7fae71b3d2d92e889bc3">&#9670;&nbsp;</a></span>is_removable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool matador::object_store::is_removable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the underlaying serializable is removable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The serializable to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if serializable is removable. </dd></dl>

</div>
</div>
<a id="ae022fdb3474ca0178b4c7ce33745c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae022fdb3474ca0178b4c7ce33745c28b">&#9670;&nbsp;</a></span>mark_modified() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::mark_modified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>optr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks the given object_ptr as modified and notifies all transactions</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Object type of the object_ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optr</td><td>The modified object_ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48ab9d800b4e80c9e006a4edda38ceb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ab9d800b4e80c9e006a4edda38ceb2">&#9670;&nbsp;</a></span>mark_modified() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::mark_modified </td>
          <td>(</td>
          <td class="paramtype">object_proxy *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks the given object proxy as modified and notifies all transactions</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Object type of the proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The modified object proxy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad076d64df93f6f0bdfa9dbabcdce0c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad076d64df93f6f0bdfa9dbabcdce0c4e">&#9670;&nbsp;</a></span>on_proxy_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::on_proxy_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(object_proxy *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback when an object proxy is deleted from the object store</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>To be called when an object proxy is deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2325edd1585f3327cd58066cc372b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2325edd1585f3327cd58066cc372b27">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::remove </td>
          <td>(</td>
          <td class="paramtype">object_proxy *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_if_deletable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the given object_proxy. The <a class="el" href="classmatador_1_1prototype__node.html" title="Holds the prototype of a concrete serializable.">prototype_node</a> id extracted from the given proxy to remove the proxy from its proxy list.</p>
<p>If the notify flag is true all observers are notified on successfull deletion.</p>
<p>If check_if_deletable flag is true method checks if the proxy is deletable.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object represented by the object_proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The object_proxy to be removed. </td></tr>
    <tr><td class="paramname">check_if_deletable</td><td>If true methods checks if proxy is deletable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf61c1ee9ff26ed9ac8668e1f7537539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf61c1ee9ff26ed9ac8668e1f7537539">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacematador.html#ac6d6aef84f36a8c232344eff3884d114">object_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes an object from the object store. After successful removal the object is set to zero and isn't valid any more.</p>
<p>Before removal is done a reference and pointer counter check is done. If at least one counter is greater than zero the object can't be removed and false is returned.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmatador_1_1object__exception.html" title="An serializable exception class.">object_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Object to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acad2d69572e29b0a3e4c8fe4286c3e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad2d69572e29b0a3e4c8fe4286c3e28">&#9670;&nbsp;</a></span>remove_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matador::object_store::remove_proxy </td>
          <td>(</td>
          <td class="paramtype">object_proxy *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the given object_proxy. The <a class="el" href="classmatador_1_1prototype__node.html" title="Holds the prototype of a concrete serializable.">prototype_node</a> id extracted from the given proxy to remove the proxy from its proxy list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The object_proxy to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a851581e1063a089f27a34991561d1373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851581e1063a089f27a34991561d1373">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t matador::object_store::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return count of prototype nodes</p>
<dl class="section return"><dt>Returns</dt><dd>Count of prototype nodes </dd></dl>

</div>
</div>
<a id="a478cb2f115bb06ef933d64db1dabe961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478cb2f115bb06ef933d64db1dabe961">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string matador::object_store::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the typename to the given class. If no typename is found an empty string is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">class</td><td>type to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding typename </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>matador/object/object_store.hpp</li>
</ul>
</div><!-- contents -->
